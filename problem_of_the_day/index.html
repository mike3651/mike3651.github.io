<!-- 
	This is the second page which I have attempted to make in order to help my fellow peers out. Javascript will be added later.

	Â©Michael Wilson -->
<!DOCTYPE html>
<head>
	<!-- css file -->
	<link rel="stylesheet" type="text/css" href="index.css">

	<!-- JQUERY -->
	<script src="https://code.jquery.com/jquery-3.2.1.js" integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE=" crossorigin="anonymous"></script>

	<!-- js file -->
	<script type="text/javascript" src="index.js"></script>

	<title>Problem of the day</title>
</head>
<body>
	<h1>Can you solve the problem of the day?</h1>

	<!-- HIGHLIGHTED PROBLEM -->
	<div class="container">
		<a id="special-highlight" href="#linkedlist-intersection">	
		<div id="highlight">
			<h2>Given two linked lists, find where they interesect</h2>
			<div class="wrapper"></div>

			<!-- hidden div revealing input box for problem -->
			<!-- <div id="problem">
				<input type="string"/><button>Solve!</button>

				<div id="output">
				</div>
			</div> -->
		</div></a>
	</div>

	<!-- List of solved problems -->
	<h2>Problem set</h2>
	<ul>
		<li><a href="#arrays">Arrays</a></li>
		<ul>
			<li><a href="#char-ext">Character extension</a></li>
			<li><a href="#smoc">Second most occurring character</a></li>	
		</ul>
		<li><a href="#linkedlists">Linked lists</a></li>	
		<ul>
			<li><a href="#kth-from-last">Kth from last</a></li>
			<li><a href="#linkedlist-loop">Loop detection</a></li>
			<li><a href="#linkedlist-palindrome">Palindrome</a></li>
			<li><a href="#linkedlist-reverse">Reverse</a></li>
			<li><a href="#linkedlist-merge">Merge</a></li>
			<li><a href="#linkedlist-intersection">Intersection</a></li>
		</ul>
	</ul>


	<!-- SEGMENT FOR ARRAYS -->
	<div id="arrays">
		<h2>Array problems</h2>
		<!-- Second most occurring character solved -->
		<div id="smoc">
			<h3>Second most occurring character</h3>
			<h4>The problem:</h4>
			<p>Given a string, find the second most common character</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Keep track of the characters and frequencies in some sort of <span title="Data structure">DS</span></li>
				<li>Iterate through DS to find max occuring character</li>
				<li>Iterate through DS to find second max occuring character</li>
				<li>Return second max occurring character</li>
			</ol>

			<h4>The pseudocode</h4>	
<pre>	
<code>
# Finds the second most occurring character in a string
#
# param str: The string to search through
# return: str !empty ? second most occurring character : null

findSecond(str):  
   hm = new hashmap&lt;char, int&gt;();
   for each character <span title="is in">&in;</span> str:
      if c &in; hm:
         hm.put(c, hm.get(c)++)
      else:
         hm.put(c, 1)

   max = compare = 0, maxKey = ''
   for each key &in; hm:
      compare = hm.get(key)
      if compare > max:
         maxKey = key
         max = compare

   secondMax = 0, returnKey = ''
   for each key &in; hm &amp; != maxKey:
      compare = hm.get(key)
      if compare > secondMax:
         secondMax = compare
         returnKey = key

   return returnKey
</code>
</pre>		
		</div>

		<!-- character extension problem -->
		<div id="char-ext">
			<h3>Character extension</h3>
			<h4>The problem:</h4>
			<p>Given a string with a pattern of a character followed by a number, repeated M times,
				Return a new string with each character repeated X number of times where X is the number 
			 	which follows said character.</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Read through the string</li>
				<ol>
					<li>Mark the character to be duplicated</li>
					<li>Mark the number of times to duplicate</li>
					<li>Append the character duplicated times to some new string-like object</li>
				</ol>
				<li>Return the string-like object</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Returns a new string with each character repeated X number of times where X is the number which follows said character.
#
# param str: The string to go off of 
# return: String-like object with characters repeated X times

stringExt(str):
   sb = new <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">StringBuilder</a>
   from i = 0 to str.length:
      c = str[i], n = parseInt(str[i + 1])
      i+=2
      from j = 1 to n:
         sb.append(c)
   return string(sb)
</code>
</pre>
		</div>
	</div>

<!-- SEGMENT FOR LINKED LISTS -->
	<div id="linkedlists">
		<h2>What is a linkedlist?</h2>
		<p>A linked list is a collection of a bunch of node objects which are 'linked' together by references. Each node contains data and a reference to the next node in the chain. </p>
<pre>
<code>
# Simple generic node object

class LinkedNode<T> {
   LinkedNode<T> next;
   T data;

   /**
    * Overloaded constructor
    *
    * @param data The data to store in this node */
   public LinkedNode(T data) {
      this.data = data
   }
}

</code>
</pre>
		<h4>Chain of nodes together, aka LinkedList</h4>
		<p>|Node|--> |Node|-->  NULL</p>

		<h3>Exmaple linkedlist class</h3>
<pre>
<code>
public class LinkedList<T> {
   private LinkedNode<T> head, currentNode;
   
   /* Default constructor */
   public LinkedList<T>(){
      this(null);
   }

   /**
    * Overloaded constructor
    *
    * @param element The data to take in */
   public LinkedList<T>(T element) {
      head = new LinkedNode<T>(element);
      currentNode = head;
   }

   /**
    * Method which gets the next element in the chain
    *
    * @return The next node in the list */
   public LinkedNode<T> getNext() {      
      return current = ((current == null || current.next == null) ? null : current.next);
   }

   /** 
    * Method that sets the next node in the chain 
    * 
    * @param node The node to chain to */
   public void setNext(LinkedNode<T> node) {
      current.next = node;
      current = current.next;
   }

   /** 
    * Method that returns the current node 
    *
    * @return The current node's data */
   public T getElement() {
      return current.data;
   }

   /** 
    * Sets a value in the current node
    * 
    * @param element The data to be set in the node */
   public void setElement(T element) {
      current.data = data;
   }

   /** 
    * Class only accessible in LinkedList 
    * Since this is a simple class the fields in here will be public */
   private class LinkedNode<T> {
      public T data;
      public LinkedNode<T> next;

      /**
       * Contstructs a new linkednode
       *
       * @param data The data passed in */
      public LinkedNode(T data) {
         this.data = data;
      }  
   }
}
</code>
</pre>

<!-- SEGMENT FOR LINKED LISTS -->
		<h2>Linked list problems</h2>

		<div id="kth-from-last">
			<h3>Kth from last</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, find the kth from the last node</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers at the front of the list</li>
				<li>Set them k steps apart from each other</li>
				<li>Move each pointer one node at a time until the furthest node, from the front, is null</li>
				<li>Return the non null node</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Finds the kth from the last node in a singly linked list
#
# param k: The index from the end
# param list: The linked list to look through
# return: The kth node from the end of the list

kthFromLast(k, list):
   if isEmpty(list):
      return null
   
   kth, end = list.front
   from i = 1 to k:
      end = end.next
   
   if end is null:
      return null

   while end is not null:
      kth = kth.next
      end = end.next
   return end
</code>
</pre>

		</div>

		<div id="linkedlist-loop">
			<h3>Loop detection</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, determine if a loop exists</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers</li>
				<li>The first pointer will take one step at a time and the other will take two at a time</li>
				<li>If at any point the first or second pointer is null terminate loop and return false</li>
				<li>At this point the first &amp; second pointers haven't terminated and are bound to equal one another so terminate loop and return true</li>				
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Checks to see if there is a loop in the linked list
#
# param list: The list to check
# return: True if loop is detected, False otherwise

loopDetect(list):
   if list.head or list.head.next is null:
      return False
   
   first = list.head, second = first.next
   while second is not null and first is not null:
      if first.data is equal to second.data:
         return True

   return False

</code>
</pre>
		</div>
<pre>
<code>
</code>
</pre>
		<div id="linkedlist-palindrome">
			<h3>Palindrome</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, determine if it is a palindrome</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers</li>			
				<li>Start one pointer at the original list and then the second at a reverse of the original</li>
				<li>Loop through each list at the same time and check to see if each node is equivalent</li>
				<li>If at any points the nodes are not equivalent return false, else return true</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Checks to see if a list is a palindrome {in place}
#
# param list: The list to check
# return: True if plaindrome, false otherwise

palindrome(list):
   pointer_1 -> list
   pointer_2 -> reverse(list)

   while pointer_1 is not null:
      if pointer_1.data is not equal to pointer_2.data:
          return False
   return True
</code>
</pre>
		</div>

		<div id="linkedlist-reverse">
			<h3>Reverse</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, reverse it</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Keep track of temp, current, previous nodes</li>
				<li>Set current to be the front node and previous to be null</li>
				<li>Loop through the list while current is not null</li>
				<ol>
					<li>Set temp to be current.next</li>
					<li>Set current.next to be previous</li>
					<li>Set previous to be equal to current</li>
					<li>Set current to be temp</li>
				</ol>
			</ol>
			<h4>The pseudocode</h4>			
<pre>
<code>
# Reverses the contents of a linked list
#
# param list: The list to reverse
# return: The list reversed

reverse(list):
   prev = null, current = list.head, temp
   while current.next is not null:
      temp = current.next
      current.next = prev
      prev = current
      current = temp
   return current
</code>
	</pre>

		<div id="linkedlist-merge">
			<h3>Merge</h3>
			<h4>The problem:</h4>
			<p>Given two ascendingly sorted singly linked lists, merge them together</p>
			<h4>The thought process:</h4>
			<ol>
				<li>generate two pointers to each of the lists {for traversal} and third pointer to null</li>
				<li>while the two traversal pointers are not null, add the smallest curr value to third pointer</li>
				<li>Check to see which pointer is not null and then traverse to the end of its list while appending to third pointer</li>			
			</ol>
			<h4>The pseudocode</h4>
<pre>
<code>
# Merges two ascendingly sorted linked lists togeterh 
#
# param p_1: The reference to the first list
# param p_2: The reference to the second list
# return: reference to the merged list

merge(p_1, p_2):
   p1 = p1.head, p2 = p_2.head, p3 = null
   
   while p1 and p2 are not null:
      p1.data > p2.data:
         add(p3, p2.data)
         p2 = p2.next
      else:
         add(p3, p1.data)
         p1 = p1.next

   p1 is not null:
      while p1 is not null:
         add(p3, p1.data)
         p1 = p1.next

   else p2 is not null:
      while p2 is not null:
         add(p3, p2.data)
         p2 = p2.next

   return p3
</code>
</pre>
		</div>
		<div id="linkedlist-intersection">
			<h3>Intersect</h3>
			<h4>The problem:</h4>
			<p>Given two singly linkedlists, find out where they intersect</p>
			<h4>The thought process:</h4>
			<ol>
				<li>generate two pointers to each of the first and second list</li>
				<li>while each pointer is not null:</li>
				<ol>
					<li>if the addresses are equal return current node</li>
					<li>check to see which one has the lower address and then increment that pointer</li>
				</ol>
				<li>If nothing has been returned yet, return null since the lists can't intersect</li>
			</ol>
			<h4>The pseudocode</h4>
<pre>
<code>
# Finds the intersection between two linked lists
#
# param list_1: reference to the first list
# param list_2: reference to the second list
# return: The node at which the lists intersect, none if non existent

intersection(list_1, list_2):
   p1 = list_1.head, p2 = list_2.head
   
   while p1 and p2 are not null:
      if &amp;p1 is &amp;p2:
         return p1
      
      if &amp;p1 is greater than &amp;p2:
         p2 = p2.next
      
      else:
         p1  = p1.next

   return none
</code>
</pre>
		</div>
	</div>


</body>
</html>

