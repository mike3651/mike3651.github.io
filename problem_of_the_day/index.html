<!-- 
	This is the second page which I have attempted to make in order to help my fellow peers out. Javascript will be added later.

	Â©Michael Wilson -->
<!DOCTYPE html>
<head>
	<!-- css file -->
	<link rel="stylesheet" type="text/css" href="index.css">

	<!-- JQUERY -->
	<script src="https://code.jquery.com/jquery-3.2.1.js" integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE=" crossorigin="anonymous"></script>

	<!-- js file -->
	<script type="text/javascript" src="index.js"></script>

	<title>Problem of the day</title>
</head>
<body>
	<h1>Can you solve the problem of the day?</h1>

	<!-- HIGHLIGHTED PROBLEM -->
	<div class="container">
		<a id="special-highlight" href="#linkedlist-loop">	
		<div id="highlight">
			<h2>Detect if a loop can be found in a singly linked list</h2>
			<div class="wrapper"></div>

			<!-- hidden div revealing input box for problem -->
			<!-- <div id="problem">
				<input type="string"/><button>Solve!</button>

				<div id="output">
				</div>
			</div> -->
		</div></a>
	</div>

	<!-- List of solved problems -->
	<h2>Problem set</h2>
	<ul>
		<li><a href="#arrays">Arrays</a></li>
		<ul>
			<li><a href="#char-ext">Character extension</a></li>
			<li><a href="#smoc">Second most occurring character</a></li>	
		</ul>
		<li><a href="#linkedlists">Linked lists</a></li>	
		<ul>
			<li><a href="#kth-from-last">Kth from last</a></li>
		</ul>
	</ul>


	<!-- SEGMENT FOR ARRAYS -->
	<div id="arrays">
		<h2>Array problems</h2>
		<!-- Second most occurring character solved -->
		<div id="smoc">
			<h3>Second most occurring character</h3>
			<h4>The problem:</h4>
			<p>Given a string, find the second most common character</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Keep track of the characters and frequencies in some sort of <span title="Data structure">DS</span></li>
				<li>Iterate through DS to find max occuring character</li>
				<li>Iterate through DS to find second max occuring character</li>
				<li>Return second max occurring character</li>
			</ol>

			<h4>The pseudocode</h4>	
<pre>	
<code>
# Finds the second most occurring character in a string
#
# param str: The string to search through
# return: str !empty ? second most occurring character : null

findSecond(str):  
   hm = new hashmap&lt;char, int&gt;();
   for each character <span title="is in">&in;</span> str:
      if c &in; hm:
         hm.put(c, hm.get(c)++)
      else:
         hm.put(c, 1)

   max = compare = 0, maxKey = ''
   for each key &in; hm:
      compare = hm.get(key)
      if compare > max:
         maxKey = key
         max = compare

   secondMax = 0, returnKey = ''
   for each key &in; hm &amp; != maxKey:
      compare = hm.get(key)
      if compare > secondMax:
         secondMax = compare
         returnKey = key

   return returnKey
</code>
</pre>		
		</div>

		<!-- character extension problem -->
		<div id="char-ext">
			<h3>Character extension</h3>
			<h4>The problem:</h4>
			<p>Given a string with a pattern of a character followed by a number, repeated M times,
				Return a new string with each character repeated X number of times where X is the number 
			 	which follows said character.</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Read through the string</li>
				<ol>
					<li>Mark the character to be duplicated</li>
					<li>Mark the number of times to duplicate</li>
					<li>Append the character duplicated times to some new string-like object</li>
				</ol>
				<li>Return the string-like object</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Returns a new string with each character repeated X number of times where X is the number which follows said character.
#
# param str: The string to go off of 
# return: String-like object with characters repeated X times

stringExt(str):
   sb = new <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">StringBuilder</a>
   from i = 0 to str.length:
      c = str[i], n = parseInt(str[i + 1])
      i+=2
      from j = 1 to n:
         sb.append(c)
   return string(sb)
</code>
</pre>
		</div>
	</div>

<!-- SEGMENT FOR LINKED LISTS -->
	<div id="linkedlists">
		<h2>What is a linkedlist?</h2>
		<p>A linked list is a collection of a bunch of node objects which are 'linked' together by references</p>

		<h3>Exmaple linkedlist class</h3>
<pre>
<code>
public class LinkedList<T> {
   private LinkedNode<T> head, currentNode;
   
   /* Default constructor */
   public LinkedList<T>(){
      this(null);
   }

   /**
    * Overloaded constructor
    *
    * @param element The data to take in */
   public LinkedList<T>(T element) {
      head = new LinkedNode<T>(element);
      currentNode = head;
   }

   /**
    * Method which gets the next element in the chain
    *
    * @return The next node in the list */
   public LinkedNode<T> getNext() {
      
      return current = ((current == null || current.next == null) ? null : current.next);
   }

   /** 
    * Method that sets the next node in the chain 
    * 
    * @param node The node to chain to */
   public void setNext(LinkedNode<T> node) {
      current.next = node;
      current = current.next;
   }

   /** 
    * Method that returns the current node 
    *
    * @return The current node's data */
   public T getElement() {
      return current.data;
   }

   /** 
    * Sets a value in the current node
    * 
    * @param element The data to be set in the node */
   public void setElement(T element) {
      current.data = data;
   }

   /** 
    * Class only accessible in LinkedList 
    * Since this is a simple class the fields in here will be public */
   private class LinkedNode<T> {
      public T data;
      public LinkedNode<T> next;

      /**
       * Contstructs a new linkednode
       *
       * @param data The data passed in */
      public LinkedNode(T data) {
         this.data = data;
      }  
   }
}
</code>
</pre>


		<h2>Linked list problems</h2>

		<div id="kth-from-last">
			<h3>Kth from last</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, find the kth from the last node</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers at the front of the list</li>
				<li>Set them k steps apart from each other</li>
				<li>Move each pointer one node at a time until the furthest node, from the front, is null</li>
				<li>Return the non null node</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Finds the kth from the last node in a singly linked list
#
# param k: The index from the end
# param list: The linked list to look through
# return: The kth node from the end of the list

kthFromLast(k, list):
   if isEmpty(list):
      return null
   
   kth, end = list.front
   from i = 1 to k:
      end = end.next
   
   if end is null:
      return null

   while end is not null:
      kth = kth.next
      end = end.next
   return end
</code>
</pre>

		</div>

		<div id="linkedlist-loop">
			<h3>Loop detection</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, determine if a loop exists</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers</li>
				<li>The first pointer will take one step at a time and the other will take two at a time</li>
				<li>If at any point the first or second pointer is null terminate loop and return false</li>
				<li>At this point the first &amp; second pointers haven't terminated and are bound to equal one another so terminate loop and return true</li>				
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Checks to see if there is a loop in the linked list
#
# param list: The list to check
# return: True if loop is detected, False otherwise

loopDetect(list):
   if list.head or list.head.next is null:
      return False
   
   first = list.head, second = first.next
   while second is not null and first is not null:
      if first.data is equal to second.data:
         return True

   return False

</code>
</pre>
		</div>
<pre>
<code>
</code>
</pre>
	</div>

</body>
</html>