<!-- 
	This is the second page which I have attempted to make in order to help my fellow peers out. Javascript will be added later.

	Â©Michael Wilson -->
<!DOCTYPE html>
<head>
	<!-- css file -->
	<link rel="stylesheet" type="text/css" href="index.css">

	<!-- JQUERY -->
	<script src="https://code.jquery.com/jquery-3.2.1.js" integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE=" crossorigin="anonymous"></script>

	<!-- js file -->
	<script type="text/javascript" src="index.js"></script>

	<title>Problem of the day</title>
</head>
<body>
	<h1>Can you solve the problem of the day?</h1>

	<!-- HIGHLIGHTED PROBLEM -->
	<div class="container">
		<a id="special-highlight" href="#linkedlist-intersection">	
		<div id="highlight">
			<h2>Given two linked lists, find where they interesect</h2>
			<div class="wrapper"></div>

			<!-- hidden div revealing input box for problem -->
			<!-- <div id="problem">
				<input type="string"/><button>Solve!</button>

				<div id="output">
				</div>
			</div> -->
		</div></a>
	</div>

	<!-- List of solved problems -->
	<h2>Problem set</h2>
	<ul>
		<li><a href="#bits">Bits</a></li>
		<ul>
			<li><a href="#convert-to-bits">Convert to bits</a></li>
			<li><a href="#hamming-distance">Hamming distance</a></li>
		</ul>
		<li><a href="#strings">Strings</a></li>
		<ul>
			<li><a href="#string-rotation-substring">String rotation substring</a></li>
		</ul>
		<li><a href="#arrays">Arrays</a></li>
		<ul>
			<li><a href="#char-ext">Character extension</a></li>
			<li><a href="#smoc">Second most occurring character</a></li>	
		</ul>
		<li><a href="#linkedlists">Linked lists</a></li>	
		<ul>
			<li><a href="#kth-from-last">Kth from last</a></li>
			<li><a href="#linkedlist-loop">Loop detection</a></li>
			<li><a href="#linkedlist-palindrome">Palindrome</a></li>
			<li><a href="#linkedlist-reverse">Reverse</a></li>
			<li><a href="#linkedlist-merge">Merge</a></li>
			<li><a href="#linkedlist-intersection">Intersection</a></li>
		</ul>
		<li><a href="#bst">Binary trees</a></li>
		<ul>
			<li><a href="#makeTree">Make Tree from sorted array</a></li>
		</ul>
		<li><a href="#math">Mathematics</a></li>
		<ul>
			<li><a href="#complex-mult">Complex multiplication</a></li>
		</ul>
	</ul>

	<!-- SEGMENT FOR BIT PROBLEMS -->
	<div id="bits">
		<h2>Bit problems</h2>
		<div id="convert-to-bits">
			<h3>Convert to bits</h3>
			<h4>The problem:</h4>
			<p>Given a number, find its bit representaiton</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create a number x(for positioning in array) which will be set to 1, a 32 bit sized array, and an unsigned integer</li>
				<li>Set the unsigned int to be 1 shifted to the left 31 spaces</li>
				<li>From i at its starting point to i > 0 and in incerements down by power of 2:</li>
				<ol>
					<li>bit[32 - x] = is set to the number anded with i to check if the appropriate bit is a one or zero</li>
					<li>x is decreased</li>
				</ol>
				<li>return the bit array</li>
			</ol>

			<h4>The pseudocode</h4>	
<pre>
<code>
# Gives a bit representation of a number
#
# param n: The number to get the bit representation of
# return: An array of bits representing the number

bitRepresentation(n):
   b = bit[32], unsigned i, int x = 1

   from i = 1 &lt;&lt; 32 to i > 0:
      b[32 - x] = n &amp; i;
      x--;
      i /= 2;
</code>
</pre>		
		<h5>Problem from <a href="https://geeksforgeeks.org">geeksforgeeks</a></h5>
		</div>

		<div id="hamming-distance">
			<h3>Hamming distance</h3>
			<h4>The problem:</h4>
			<p>Given two numbers x &amp; y, find the number of positions in which the bits differ</p>
			<h4>The thought process:</h4>
			<ol>
				<li>convert x &amp; y to their respective bit forms and set distance to 0</li>
				<li>while iterating through the bits:</li>
				<ol>
					<li>If the x<sub>bit</sub> and y<sub>bit</sub> differ then increase distance</li>
				</ol>	
				<li>Return the distance</li>
			</ol>

			<h4>The pseudocode</h4>	
<pre>
<code>
# Finds the hamming distance between two numbers
#
# param x: The first number
# param y: The second number
# return: The hamming distance between x &amp; y

ham(x, y):
   x_arr = bitRepresentation(x), y_arr = bitRepresentaiton(y), distance = 0

   for each bit &in; x &amp; y:
      if x<sub>bit</sub> == y<sub>bit</sub>:
         distance++

   return distance
</code>
</pre>
		<h5>Problem from <a href="https://leetcode.com">leetcode</a></h5>			
		</div>		

	</div>

<!-- SEGMENT FOR STRINGS -->
	<div id="strings">
		<div id="string-rotation-substring">
			<h3>String rotation substring</h3>
			<h4>The problem:</h4>
			<p>Given two strings, find out if one of them is a rotation of the other</p>
			<h4>The thought process:</h4>
			<ol>
				<li>If the lengths differ return false</li>
				<li>Add one string to iteself and then return true if a sequence of characters in the new string is equal to the second string, otherwise return false</li>
			</ol>

			<h4>The pseudocode</h4>
<pre>
<code>
# Checks to see if two strings arae rotations of one another
#
# param str1: The first string
# param str2: The second string
# return: True if one string is a rotation of the other, false otherwise

substringRotation(str1, str2):
   if len(str1) != len(str2):
      return false

   str1 += str1
   return str1.contains(str2)
</code>
</pre>

		<h5>Problem from <a href="https://www.facebook.com/gayle">Cracking the code interview</a></h5>			
		</div>
	</div>


	<!-- SEGMENT FOR ARRAYS -->
	<div id="arrays">
		<h2>Array problems</h2>
		<!-- Second most occurring character solved -->
		<div id="smoc">
			<h3>Second most occurring character</h3>
			<h4>The problem:</h4>
			<p>Given a string, find the second most common character</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Keep track of the characters and frequencies in some sort of <span title="Data structure">DS</span></li>
				<li>Iterate through DS to find max occuring character</li>
				<li>Iterate through DS to find second max occuring character</li>
				<li>Return second max occurring character</li>
			</ol>

			<h4>The pseudocode</h4>	
<pre>	
<code>
# Finds the second most occurring character in a string
#
# param str: The string to search through
# return: str !empty ? second most occurring character : null

findSecond(str):  
   hm = new hashmap&lt;char, int&gt;();
   for each character <span title="is in">&in;</span> str:
      if c &in; hm:
         hm.put(c, hm.get(c)++)
      else:
         hm.put(c, 1)

   max = compare = 0, maxKey = ''
   for each key &in; hm:
      compare = hm.get(key)
      if compare > max:
         maxKey = key
         max = compare

   secondMax = 0, returnKey = ''
   for each key &in; hm &amp; != maxKey:
      compare = hm.get(key)
      if compare > secondMax:
         secondMax = compare
         returnKey = key

   return returnKey
</code>
</pre>
		<h5>Problem from <a href="https://careercup.com">careercup</a></h5>		
		</div>

		<!-- character extension problem -->
		<div id="char-ext">
			<h3>Character extension</h3>
			<h4>The problem:</h4>
			<p>Given a string with a pattern of a character followed by a number, repeated M times,
				Return a new string with each character repeated X number of times where X is the number 
			 	which follows said character.</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Read through the string</li>
				<ol>
					<li>Mark the character to be duplicated</li>
					<li>Mark the number of times to duplicate</li>
					<li>Append the character duplicated times to some new string-like object</li>
				</ol>
				<li>Return the string-like object</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Returns a new string with each character repeated X number of times where X is the number which follows said character.
#
# param str: The string to go off of 
# return: String-like object with characters repeated X times

stringExt(str):
   sb = new <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">StringBuilder</a>
   from i = 0 to str.length:
      c = str[i], n = parseInt(str[i + 1])
      i+=2
      from j = 1 to n:
         sb.append(c)
   return string(sb)
</code>
</pre>
		<h5>Problem from <a href="https://careercup.com">careercup</a></h5>
		</div>
	</div>

<!-- SEGMENT FOR LINKED LISTS -->
	<div id="linkedlists">
		<h2>What is a linkedlist?</h2>
		<p>A linked list is a collection of a bunch of node objects which are 'linked' together by references. Each node contains data and a reference to the next node in the chain. </p>
<pre>
<code>
# Simple generic node object

class LinkedNode<T> {
   LinkedNode<T> next;
   T data;

   /**
    * Overloaded constructor
    *
    * @param data The data to store in this node */
   public LinkedNode(T data) {
      this.data = data
   }
}

</code>
</pre>
		<h4>Chain of nodes together, aka LinkedList</h4>
		<p>|Node|--> |Node|-->  NULL</p>

		<h3>Example linkedlist class</h3>
<pre>
<code>
public class LinkedList<T> {
   private LinkedNode<T> head, currentNode;
   
   /* Default constructor */
   public LinkedList<T>(){
      this(null);
   }

   /**
    * Overloaded constructor
    *
    * @param element The data to take in */
   public LinkedList<T>(T element) {
      head = new LinkedNode<T>(element);
      currentNode = head;
   }

   /**
    * Method which gets the next element in the chain
    *
    * @return The next node in the list */
   public LinkedNode<T> getNext() {      
      return current = ((current == null || current.next == null) ? null : current.next);
   }

   /** 
    * Method that sets the next node in the chain 
    * 
    * @param node The node to chain to */
   public void setNext(LinkedNode<T> node) {
      current.next = node;
      current = current.next;
   }

   /** 
    * Method that returns the current node 
    *
    * @return The current node's data */
   public T getElement() {
      return current.data;
   }

   /** 
    * Sets a value in the current node
    * 
    * @param element The data to be set in the node */
   public void setElement(T element) {
      current.data = data;
   }

   /** 
    * Class only accessible in LinkedList 
    * Since this is a simple class the fields in here will be public */
   private class LinkedNode<T> {
      public T data;
      public LinkedNode<T> next;

      /**
       * Contstructs a new linkednode
       *
       * @param data The data passed in */
      public LinkedNode(T data) {
         this.data = data;
      }  
   }
}
</code>
</pre>

<!-- SEGMENT FOR LINKED LISTS -->
		<h2>Linked list problems</h2>

		<div id="kth-from-last">
			<h3>Kth from last</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, find the kth from the last node</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers at the front of the list</li>
				<li>Set them k steps apart from each other</li>
				<li>Move each pointer one node at a time until the furthest node, from the front, is null</li>
				<li>Return the non null node</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Finds the kth from the last node in a singly linked list
#
# param k: The index from the end
# param list: The linked list to look through
# return: The kth node from the end of the list

kthFromLast(k, list):
   if isEmpty(list):
      return null
   
   kth, end = list.front
   from i = 1 to k:
      end = end.next
   
   if end is null:
      return null

   while end is not null:
      kth = kth.next
      end = end.next
   return end
</code>
</pre>
		<h5>Problem from <a href="https://hackerrank.com">hackerrank</a></h5>
		</div>

		<div id="linkedlist-loop">
			<h3>Loop detection</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, determine if a loop exists</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers</li>
				<li>The first pointer will take one step at a time and the other will take two at a time</li>
				<li>If at any point the first or second pointer is null terminate loop and return false</li>
				<li>At this point the first &amp; second pointers haven't terminated and are bound to equal one another so terminate loop and return true</li>				
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Checks to see if there is a loop in the linked list
#
# param list: The list to check
# return: True if loop is detected, False otherwise

loopDetect(list):
   if list.head or list.head.next is null:
      return False
   
   first = list.head, second = first.next
   while second is not null and first is not null:
      if first.data is equal to second.data:
         return True

   return False

</code>
</pre>
		<h5>Problem from friend @ Extrahop</h5>
		</div>
<pre>
<code>
</code>
</pre>
		<div id="linkedlist-palindrome">
			<h3>Palindrome</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, determine if it is a palindrome</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Create two pointers</li>			
				<li>Start one pointer at the original list and then the second at a reverse of the original</li>
				<li>Loop through each list at the same time and check to see if each node is equivalent</li>
				<li>If at any points the nodes are not equivalent return false, else return true</li>
			</ol>
			<h4>The pseudocode</h4>	
<pre>
<code>
# Checks to see if a list is a palindrome {in place}
#
# param list: The list to check
# return: True if plaindrome, false otherwise

palindrome(list):
   pointer_1 -> list
   pointer_2 -> reverse(list)

   while pointer_1 is not null:
      if pointer_1.data is not equal to pointer_2.data:
          return False
   
   return True
</code>
</pre>
		<h5>Problem from <a href="https://careercup.com">careercup</a></h5>
		</div>

		<div id="linkedlist-reverse">
			<h3>Reverse</h3>
			<h4>The problem:</h4>
			<p>Given a singly linked list, reverse it</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Keep track of temp, current, previous nodes</li>
				<li>Set current to be the front node and previous to be null</li>
				<li>Loop through the list while current is not null</li>
				<ol>
					<li>Set temp to be current.next</li>
					<li>Set current.next to be previous</li>
					<li>Set previous to be equal to current</li>
					<li>Set current to be temp</li>
				</ol>
			</ol>
			<h4>The pseudocode</h4>			
<pre>
<code>
# Reverses the contents of a linked list
#
# param list: The list to reverse
# return: The list reversed

reverse(list):
   prev = null, current = list.head, temp
   
   while current.next is not null:
      temp = current.next
      current.next = prev
      prev = current
      current = temp
   
   return current
</code>
</pre>
		<h5>Problem from <a href="https://careercup.com">careercup</a></h5>

		<div id="linkedlist-merge">
			<h3>Merge</h3>
			<h4>The problem:</h4>
			<p>Given two ascendingly sorted singly linked lists, merge them together</p>
			<h4>The thought process:</h4>
			<ol>
				<li>generate two pointers to each of the lists {for traversal} and third pointer to null</li>
				<li>while the two traversal pointers are not null, add the smallest curr value to third pointer</li>
				<li>Check to see which pointer is not null and then traverse to the end of its list while appending to third pointer</li>			
			</ol>
			<h4>The pseudocode</h4>
<pre>
<code>
# Merges two ascendingly sorted linked lists togeter
#
# param p_1: The reference to the first list
# param p_2: The reference to the second list
# return: reference to the merged list

merge(p_1, p_2):
   p1 = p1.head, p2 = p_2.head, p3 = null
   
   while p1 and p2 are not null:
      p1.data > p2.data:
         add(p3, p2.data)
         p2 = p2.next
      
      else:
         add(p3, p1.data)
         p1 = p1.next

   p1 is not null:
      while p1 is not null:
         add(p3, p1.data)
         p1 = p1.next

   else p2 is not null:
      while p2 is not null:
         add(p3, p2.data)
         p2 = p2.next

   return p3
</code>
</pre>
		<h5>Problem from <a href="https://leetcode.com">leetcode</a></h5>
		</div>
		<div id="linkedlist-intersection">
			<h3>Intersect</h3>
			<h4>The problem:</h4>
			<p>Given two singly linkedlists, find out where they intersect</p>
			<h4>The thought process:</h4>
			<ol>
				<li>generate two pointers to each of the first and second list</li>
				<li>while each pointer is not null:</li>
				<ol>
					<li>if the addresses are equal return current node</li>
					<li>check to see which one has the lower address and then increment that pointer</li>
				</ol>
				<li>If nothing has been returned yet, return null since the lists can't intersect</li>
			</ol>
			<h4>The pseudocode</h4>
<pre>
<code>
# Finds the intersection between two linked lists
#
# param list_1: reference to the first list
# param list_2: reference to the second list
# return: The node at which the lists intersect, none if non existent

intersection(list_1, list_2):
   p1 = list_1.head, p2 = list_2.head
   
   while p1 and p2 are not null:
      if &amp;p1 is &amp;p2:
         return p1
      
      if &amp;p1 is greater than &amp;p2:
         p2 = p2.next
      
      else:
         p1 = p1.next

   return none
</code>
</pre>
		<h5>Problem from <a href="https://geeksforgeeks.org">geeksforgeeks</a></h5>
		</div>
	</div>

	<!-- SEGMENT FOR BINARY TREES -->
	<div id="bst">
		<div id="makeTree">
			<h3>Sorted array to BST</h3>
			<h4>The problem:</h4>
			<p>Given sorted list, construct a tree</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Find the midpoint of the array</li>
				<li>Create a root node with the midpoints data</li>
				<ol>
					<li>While there are still valid positions to look at in the array</li>
					<li>Repeat first two steps for left subtree and left half of array</li>
					<li>Repeat first two steps for right subtree and right half of array</li>
				</ol>
			</ol>
			<h4>The pseudocode</h4>
<pre>
<code>
# Constructs a tree from a sorted array
#
# param arr: The sorted array
# param start: The start index
# param end: The ending index
# param r: The root of the tree
# return: The root of the tree

makeTree(arr, start, end, r):
   if start &lt;= end:
      mid = (start + end)/2
      r = new TreeNode(arr[mid])
      r->left = makeTree(start, mid - 1)
      r->right = makeTree(arr, mid + 1, end)

</code>
</pre>
		<h5>Problem from <a href="https://geeksforgeeks.org">geeksforgeeks</a></h5>
		</div>		
	</div>

<!-- SECTION FOR MATHEMATICS -->
	<div id="math">
		<div id="complex-mult">
			<h3>Complex number multiplication</h3>
			<h4>The problem:</h4>
			<p>Given two complex equations (in the form of strings), multiply them together and return the result as a string</p>
			<h4>The thought process:</h4>
			<ol>
				<li>Parse through each equation to get the real &amp; complex numbers</li>
				<li>Perform the appropriate foiling of the respective numbers</li>
				<li>Convert the solution to a string and return it</li>
			</ol>
			<h4>The pseudocode</h4>
<pre>
<code>
# Performs multiplication between two complex equations
#
# param str1: The first complex equation
# param str2: The second complex equation
# return: The result of multiplying both of the equations

complexMult(str1, str2):
   a = parseInt(str1[0, '+'))
   b = parseInt(str1('+', 'i'))
   c = parseInt(str2[0, '+'))
   d = parseInt(str2('+', 'i'))
   e = a * c - b * d
   f = (c * d + a * d) + 'i'
   return e + f
</code>
</pre>
			<h5>Problem from <a href="https://leetcode.com">leetcode</a></h5>
		</div>
	</div>
</body>
</html>

